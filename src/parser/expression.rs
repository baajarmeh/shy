use std::marker::PhantomData;
use std::collections::HashSet;
use std::collections::HashMap;
use std::sync::{Arc,RwLock};
// use std::rc::Rc;
//use std::cell::RefCell;
use std::borrow::BorrowMut;

use serde::{Serialize, Deserialize, Serializer, Deserializer};

use super::shy_token::{ShyToken, ShyValue};
use super::ShuntingYard;
use super::execution_context::ExecutionContext;
use super::shy_operator::ShyOperator;
use super::shy_scalar::ShyScalar;
use crate::graph::Graph;
use super::references::References;

//..................................................................

#[derive(Serialize, Deserialize, Debug, Clone)]
/// Compiled Expression that can be executed.
pub struct Expression<'a> {
    marker: PhantomData<&'a i64>,

    /// Infix Expression as a string before it was compiled
    pub expression_source: String,

    /// The constants, variable references and operators parsed from the expression_source and rearranged into postfix order.
    /// This list of tokens was generated by the shunting yard algorithm.
    pub postfix_order: Vec<ShyToken>,

    #[serde(serialize_with = "serialize_references")]
    #[serde(deserialize_with = "deserialize_references")]
    /// References to variables and property chains that this expression either defines or depends upon. 
    /// Created lazily when variables_used is called.
    references: Arc<RwLock<Option<References>>>,

    /// If true, a trace of the execution of the expression is printed as a diagnostic.
    pub trace_on: bool
}


fn serialize_references<S>(references_rrro : &Arc<RwLock<Option<References>>>, serializer: S) -> Result<S::Ok, S::Error> where S: Serializer {
    let references_ro = references_rrro.as_ref().read().unwrap();
    match *references_ro {
        Some(ref refs) => {
            serializer.serialize_some(refs)
        },
        None => serializer.serialize_none()
    }
}

/// When deserializing, set references to None, since they can be recomputed lazily as needed.
fn deserialize_references<'de, D>(_deserializer : D) -> Result<Arc<RwLock<Option<References>>>, D::Error> where D: Deserializer<'de> {
    Ok(Arc::new(RwLock::new(None)))
}


pub trait Expressive<'a> {
    fn express(&self) -> &Expression<'a>;
    fn express_mut(&mut self) -> &mut Expression<'a>;
}

impl<'a> Expressive<'a> for Expression<'a> {
    fn express(&self) -> &Self { self }
    fn express_mut(&mut self) -> &mut Self { self }
}

impl<'a> Expression<'a> {

    /// Create and compile a new Expression from a String or &str slice.
    /// If compilation fails, return an Expression with a single Error token 
    /// for which had_compile_error() will return true.
    pub fn new<S>(expr_source: S) -> Expression<'a> where S: Into<String> {
        let expr_string: String = expr_source.into();
        let shy : ShuntingYard = expr_string.clone().into(); 
        match shy.compile() {
            Ok(expr) => expr,
            _ => Expression {
                marker: PhantomData,
                expression_source: expr_string.clone(),
                postfix_order: vec![ShyToken::Error],
                references: Arc::new(RwLock::new(None)),
                trace_on: false
            }
        }
    }

    /// Create an Expression given its already compiled form. 
    pub fn new_from_parser<S>(expr_source: S, postfix : &Vec<ShyToken>) -> Expression<'a> where S: Into<String> {
        Expression { 
            marker: PhantomData,
            expression_source: expr_source.into(),
            postfix_order: postfix.clone(),
            references: Arc::new(RwLock::new(None)),
            trace_on: false
        }
    }

    /// Return true if an error occurred while compiling the expression. 
    /// The error is likely due to a syntax error in the expression, not
    /// a failure of the parser.
    pub fn had_compile_error(&self) -> bool {
        self.postfix_order.len() == 0 || self.postfix_order.iter().any(|token| token.is_error() )
    }

    /// Execute an already compiled expression against the given ExecutionContext.  
    /// 
    ///   - At the start of execution, the context is marked as **applicable**, meaning it is assumed that
    /// the `Expression` will contribute to the decision as to whether a `RuleSet` passes or fails.
    ///   - The `QuitIfFalse` operator has a side effect of marking the results of the current `Rule` as **inapplicable**
    /// if it encounters a `false` value. 
    pub fn exec(&self, context: &mut ExecutionContext<'a>) -> std::result::Result<ShyValue,String> {
        let mut output_stack : Vec<ShyValue> = vec![];
        context.is_applicable = true;
        if self.trace_on {
            println!("Tracing: {}", self.expression_source);
            Self::dump_postfix(&self.postfix_order);
        }
        for token in self.postfix_order.iter().cloned() {
            if self.trace_on {
                Self::dump_stack(&output_stack);
                println!("  Token: {:?}", token);
            }
            match token {
                ShyToken::Value(value) => output_stack.push(value),
                ShyToken::Operator(ShyOperator::QuitIfFalse) => {
                    // Shortcut the expression evaluation at the question mark, cease execution and return false. 
                    let test_result = Self::operate(&mut output_stack, ShyOperator::QuitIfFalse, context);
                    if test_result.is_falsey() {
                        context.is_applicable = false;
                        break;
                    }
                },
                ShyToken::Operator(op) => { 
                    Self::operate(&mut output_stack, op, context);
                    ()
                },
                _ => output_stack.push(ShyValue::error("Invalid token in expression".to_string()))
            }
        }
        if self.trace_on {
            Self::dump_stack(&output_stack);
        }
        // The final result of the expression is on top of the stack; pop it off and return it. 
        match output_stack.pop() {
            Some(value) => Ok(value),
            None => Err("Expression stack is empty".to_string())
        }
    }

    fn dump_stack(output_stack: &Vec<ShyValue>) {
        println!("Output Stack:");
        let mut i = 0;
        for token in output_stack.iter().cloned() {
            i = i + 1;
            println!("  {}. {:?}", i, token);
        }
    }

    fn dump_postfix(postfix_order: &Vec<ShyToken>) {
        println!("Postfix order:");
        let mut i = 0;
        for token in postfix_order.iter().cloned() {
            i = i + 1;
            println!("  {}. {:?}", i, token);
        }
    }

    /// Execute the expression with trace turned on, to print diagnostics to the console.
    /// This may have side effects upon the context!
    pub fn trace(&mut self, context: &mut ExecutionContext<'a>) -> std::result::Result<ShyValue, String> {
        self.trace_on = true;
        let exec_result = self.exec(context);
        match &exec_result {
            Ok(_) => { println!("Success"); },
            Err(msg) => { println!("Failure: {}", msg); }
        }
        println!("After execution, {:?}", context);
        self.trace_on = false;
        exec_result
    }

    /// Check if the stack has enough items to satisfy the needs of the operator
    fn is_stack_size_sufficient(output_stack: &mut Vec<ShyValue>, op: ShyOperator) -> bool {
        op.arguments() <= output_stack.len() 
    }

    /// Check if the stack is topped by an error value
    fn does_stack_have_error(output_stack: &mut Vec<ShyValue>) -> bool {
        match output_stack.last() {
            Some(ShyValue::Scalar(ShyScalar::Error(_))) => true,
            _ => false
        }
    }

    /// Apply an operator, removing tokens from the stack, computing a result, and pushing the result back on the stack.
    fn operate(output_stack: &mut Vec<ShyValue>, op: ShyOperator, context: &mut ExecutionContext<'a>) -> ShyValue {
        if Self::does_stack_have_error(output_stack) { return output_stack.last().unwrap().clone(); }
        if !Self::is_stack_size_sufficient(output_stack, op)   {
            let stack_empty = ShyValue::error(format!("Too few values on stack for operation {:?}. Size = {}", op, output_stack.len()));
            output_stack.clear();
            output_stack.push(stack_empty.clone());
            return stack_empty;
        }
        // If a unary operator, arg1 is the sole argument. 
        // If a binary operator, arg1 is the left operand.
        let mut arg1: ShyValue = 0.into();

        // If a unary operator, arg2 is unused.
        // If a binary operator, arg2 is the right operand.
        let mut arg2: ShyValue = 0.into();
        let mut _arg3: ShyValue = 0.into();

        match op.arguments() {
            1 => {
                arg1 = output_stack.pop().unwrap();
            },
            2 => {
                arg2 = output_stack.pop().unwrap();
                arg1 = output_stack.pop().unwrap();
            },
            3 => {
                _arg3 = output_stack.pop().unwrap();
                arg2 = output_stack.pop().unwrap();
                arg1 = output_stack.pop().unwrap();
            },
            _ => ()
        }
        let unimplemented = ShyValue::error(format!("Operation {} unimplemented", op.to_string()));
        let result = match op {
            ShyOperator::Load => ShyValue::load(&arg1, context),
            ShyOperator::Store => unimplemented,
            ShyOperator::Semicolon => {
                // Semicolons separate individual statements.
                // When we encounter one, wipe the stack clear to prepare for the next statement. 
                // Return the result of the previous statement. 
                // If the previous statement left the stack empty, return a NAN wrapped as a ShyValue. 
                if output_stack.len() == 0 {
                    return std::f64::NAN.into();
                }
                let intermediate_result = output_stack.pop().unwrap();
                output_stack.clear();
                return intermediate_result;
            },
            ShyOperator::FunctionCall => ShyValue::call(&arg1, &arg2, context),
            ShyOperator::OpenParenthesis => unimplemented,
            ShyOperator::CloseParenthesis => unimplemented,
            ShyOperator::Comma => ShyValue::comma(&arg1, &arg2),
            ShyOperator::OpenBracket => unimplemented,
            ShyOperator::CloseBracket => unimplemented,
            ShyOperator::Member => unimplemented,
            ShyOperator::Power => ShyValue::power(&arg1, &arg2),
            ShyOperator::Exponentiation => ShyValue::power(&arg1, &arg2),
            ShyOperator::PrefixPlusSign => ShyValue::prefix_plus(&arg1),
            ShyOperator::PrefixMinusSign => ShyValue::prefix_minus(&arg1),
            ShyOperator::PostIncrement => ShyValue::post_increment(&arg1, context),
            ShyOperator::PostDecrement => ShyValue::post_decrement(&arg1, context),
            ShyOperator::SquareRoot => ShyValue::sqrt(&arg1),
            ShyOperator::LogicalNot => ShyValue::not(&arg1),
            ShyOperator::Factorial => ShyValue::factorial(&arg1),
            ShyOperator::Match => ShyValue::matches(&arg1, &arg2),
            ShyOperator::NotMatch => ShyValue::not_matches(&arg1, &arg2),
            ShyOperator::Multiply => ShyValue::multiply(&arg1, &arg2),
            ShyOperator::Divide => ShyValue::divide(&arg1, &arg2),
            ShyOperator::Mod => ShyValue::modulo(&arg1, &arg2),
            ShyOperator::Add => ShyValue::add(&arg1, &arg2),
            ShyOperator::Subtract => ShyValue::subtract(&arg1, &arg2),
            ShyOperator::LessThan => ShyValue::less_than(&arg1, &arg2),
            ShyOperator::LessThanOrEqualTo => ShyValue::less_than_or_equal_to(&arg1, &arg2),
            ShyOperator::GreaterThan => ShyValue::greater_than(&arg1, &arg2),
            ShyOperator::GreaterThanOrEqualTo => ShyValue::greater_than_or_equal_to(&arg1, &arg2),
            ShyOperator::Equals => ShyValue::equals(&arg1, &arg2),
            ShyOperator::NotEquals => ShyValue::not_equals(&arg1, &arg2),
            ShyOperator::And => ShyValue::and(&arg1, &arg2), 
            ShyOperator::Or => ShyValue::or(&arg1, &arg2), 
            ShyOperator::Ternary => unimplemented,
            ShyOperator::Assign => ShyValue::assign(&arg1, &arg2, context),
            ShyOperator::PlusAssign => ShyValue::plus_assign(&arg1, &arg2, context),
            ShyOperator::MinusAssign => ShyValue::minus_assign(&arg1, &arg2, context),
            ShyOperator::MultiplyAssign => ShyValue::multiply_assign(&arg1, &arg2, context),
            ShyOperator::DivideAssign => ShyValue::divide_assign(&arg1, &arg2, context),
            ShyOperator::ModAssign => ShyValue::modulo_assign(&arg1, &arg2, context),
            ShyOperator::AndAssign => ShyValue::and_assign(&arg1, &arg2, context),
            ShyOperator::OrAssign => ShyValue::or_assign(&arg1, &arg2, context),
            ShyOperator::QuitIfFalse => {
                if arg1.is_falsey() {
                    output_stack.push(false.into());
                    false.into()
                }
                else {
                    output_stack.push(true.into());
                    true.into()
                }
            },
            _ => {
                output_stack.clear();
                let unsupported = ShyValue::error(format!("Invalid operator {:?}", op));
                output_stack.push(unsupported.clone());
                unsupported
            }
        };
        output_stack.push(result.clone());
        result
    }


    /// Gathers the names of all variables and property chains that are referenced by the expression,
    /// either as definitions or dependencies. 
    /// 
    /// Dependencies may be satisfied by another Rule or by the caller through the ExecutionContext itself. 
    /// 
    /// This lazily sets the Expression's references property. 
    /// 
    /// This method has no knowledge of whether a dependency is external,
    /// because to know that, you need to have a complete set of Expressions to examine, not just this one. 
    /// To determine and set the external dependencies, call apply_external_dependencies.
    pub fn variables_used(&self) -> Arc<RwLock<Option<References>>> {
        if self.references.as_ref().read().unwrap().is_some() {
            return self.references.clone();
        }
        self.lazy_init_variables_used();
        self.references.clone()
    }

    /// A clone of the References to variables defined or used by the Expression.
    pub fn get_references(&self) -> References {
        let variables_used_rro = self.variables_used(); //.clone();
        let variables_used_ro = variables_used_rro.as_ref().read().unwrap();
        match *variables_used_ro {
            Some(ref refs) => {
                refs.clone()
            },
            None => panic!("No References in Expression")
        }
    }

    /// Every dependency of the Expression found in external_dependencies will be restated 
    /// as an external_dependency inside references.
    pub fn apply_external_dependencies(&self, external_dependencies : &HashSet<String>) {
        let variables_used_rro = self.variables_used().clone();
        let mut variables_used_ro = variables_used_rro.as_ref().write().unwrap();
        match *variables_used_ro {
            Some(ref mut refs) => {
                refs.apply_external_dependencies(external_dependencies);
            },
            None => panic!("No References in Expression")
        }
    }

    /// If references holds a None, it is uninitialized, therefore initialize it lazily and return true, 
    /// else return false to say no initialization was necessary. 
    fn lazy_init_variables_used(&self) -> bool {
        if (*self.references.as_ref()).read().unwrap().is_some() {
            return false;
        }
        let mut definitions = Vec::new();
        let mut dependencies = Vec::new();

        let already_recorded = |name : &String, vec1: &Vec<String>, vec2 : &Vec<String>| -> bool { vec1.contains(name) || vec2.contains(name) };

        // If a ShyToken::Value(ShyValue::Variable(...)) or a ShyToken::Value(ShyValue::PropertyChain(...)) 
        // is followed immediately by a ShyValue:: ShyOperator::Load, it could be a definition. 
        // Otherwise it could be a dependency. Only the first occurrence of that name in the 
        // expression defines whether it is a definition or a dependency. 
        let peekaboo = &mut self.postfix_order.iter().peekable();
        while let Some(item) = peekaboo.next() {
            let followed_by_load = if let Some(ShyToken::Operator(op)) = peekaboo.peek() { *op == ShyOperator::Load } else { false };
            match item {
                ShyToken::Value(ShyValue::PropertyChain(chain)) => {
                    let chain_string = chain.join(".");
                    let skip = already_recorded(&chain_string, &definitions, &dependencies);
                    if !skip {
                        if followed_by_load { dependencies.push(chain_string); }
                        else { definitions.push(chain_string); }
                    }
                },
                ShyToken::Value(ShyValue::Variable(variable)) => {
                    let skip = already_recorded(&variable, &definitions, &dependencies);
                    if !skip {
                        if followed_by_load { dependencies.push(variable.clone()); }
                        else { definitions.push(variable.clone()); }
                    }
                },
                _ => ()
            }
        }
        // Lazy initialization of references so next call to variables_used can use the memoized value. 
        println!("In lazy_init_variables_used with {} defs and {} deps", definitions.len(), dependencies.len());
        let mut references_guard = self.references.as_ref().write().unwrap();
        references_guard.replace(References { definitions, dependencies, external_dependencies : Vec::new() });
        true
    }

    /// Build the dependency graph for a list of Expressions. 
    ///   - Variables used in an expression that are not defined are dependencies, to be represented as nodes
    ///     that point via an incoming edge to the node corresponding to the Expression. 
    ///   - Variables that an Expression defines are definitions, to be represented as nodes
    ///     to which the Expression points via an outgoing edge. 
    fn dependency_graph<'b, X>(expressions : &mut Vec<X>) -> Graph
    where X : Expressive<'b>    
     {
        // Infer the external dependencies upon variables (which must be provided by the execution context)
        // by studying all the expressions. 
        let external_deps = References::infer_external_dependencies(expressions);

        // Apply the external dependencies to the expressions, so they can discriminate between internal and external dependencies.
        // As we go, also create a concordance, to map each dependency or definition (the variable names) to a number, 
        // starting at expressions.size(). 
        // This unique number will become the node_id for that variable name in the graph. 
        let mut variable_to_id : HashMap<String, usize> = HashMap::new();
        let mut highest_node_id : usize = expressions.len() - 1;
        for expr in expressions.iter().map(|x| x.express()) {
            expr.apply_external_dependencies(&external_deps);
            let refs = expr.get_references();
            for def_name in refs.definitions.iter() {
                variable_to_id.entry(def_name.clone()).or_insert_with(|| { highest_node_id += 1; highest_node_id });
            }
            for dep_name in refs.dependencies.iter() {
                variable_to_id.entry(dep_name.clone()).or_insert_with(|| { highest_node_id += 1; highest_node_id });
            }
        }

        // Build a Graph, where: 
        //     - every variable that is defined or depended upon is a node
        //     - every expression is a node, and its zero-based position in the expressions Vec is its node_id
        //     - every variable definition is an outgoing edge from expression node to variable node
        //     - every variable reference that is to an internal (not external) dependency is 
        //       an incoming edge from variable to expression node
        let mut graph = Graph::new(highest_node_id + 1);

        for (expr_node_id, expr) in expressions.iter().map(|x| x.express()).enumerate() {
            let refs = expr.get_references();
            // Add the outgoing edges for definitions.
            for def_name in refs.definitions.iter() {
                let def_node_id = variable_to_id[def_name];
                graph.add_edge(expr_node_id, def_node_id);
            }
            // Add the incoming edges for dependencies. 
            for dep_name in refs.dependencies.iter() {
                let dep_node_id = variable_to_id[dep_name];
                graph.add_edge(dep_node_id, expr_node_id);
            }
        }
        graph
    }

    /// Given a list of expressions in an arbitrary order, **sort them topologically** 
    /// so that no Expression that relies upon a dependency
    /// is executed before that dependency is defined by another Expression, 
    /// unless that dependency is ruled an external dependency. 
    /// 
    /// Returns a Tuple with two lists. 
    ///   - The first Vec holds all the Expressions that could be ordered correctly in topologically sorted order. 
    ///   - The second Vec holds all the Expressions that had dependencies that could not be resolved in a satisfactory way. 
    ///   - If the second Vec is empty, no error occurred and a complete topological sort was performed. 
    ///   - If the second Vec is not empty, it is likely that there is a circularity in the variable references. 
    ///     This implies that the dependency graph is not a DAG (*directed acyclic graph*). 
    /// 
    /// **Complication**: Multiple expressions can define the same variable; in practice, for some expressions, 
    /// their applicability prologue will cause the evaluation to short-circuit and the definition not be performed.
    /// Thus an expression that depends upon a variable must wait until all expressions that might define that variable
    /// have been executed. 
    pub fn untangle<'b, X>(mut exprs : Vec<X>) -> (Vec<Arc<X>>, Vec<Arc<X>>) 
    where X : Expressive<'b> {
        let expression_count = exprs.len();
        let mut untangled = Vec::with_capacity(expression_count);
        let mut tangled = Vec::new();      
        let graph : Graph;
        {
            let expressions = exprs.borrow_mut();
            // Interpret the definition and use (dependency) of variables within expressions as relationships
            // in a graph. Every expression becomes a node, as well as every variable. 
            graph = Self::dependency_graph(expressions);
        }
        // Sort the graph topologically. 
        let (sorted, unsorted) = graph.sort();

        // Reorder the expressions according to the topological sort. 
        // Recognize that some of the node_ids in the solution correspond to variable names, which should be skipped. 
        // If the node_id >= expressions.len() then it is a variable node.  
        let expr_rc : Vec<Arc<X>> = exprs.into_iter().map(|x| Arc::new(x)).collect();
        for expression_node_id in sorted.iter().filter(|node_id| **node_id < expression_count) {
            // Transcribe Expressions from expr_rc to untangled via sorted.
            untangled.push(expr_rc[*expression_node_id].clone());
        }
        for expression_node_id in unsorted.iter().filter(|node_id| **node_id < expression_count) {
            // Transcribe Expressions from expr_rc to tangled via unsorted.
            tangled.push(expr_rc[*expression_node_id].clone());
        }
        (untangled, tangled)
    }
    
}

#[cfg(test)]
/// Tests of Expressions.
mod tests {
    #[allow(unused_imports)]
    use super::*;

    #[allow(unused_imports)]
    use spectral::prelude::*;

    use std::borrow::Borrow;
    use super::ShuntingYard;

    #[test]
    /// Check that variables_used finds the correct sets of variable dependencies and definitions.
    fn variables_used() {
        // x and y are defined. 
        // z is a dependency. 
        // Second use of x is a read, but since it was already defined, it is not a dependency. 
        let test_expression_text = "x = 3; y = x + well.depth;";
        let shy : ShuntingYard = test_expression_text.clone().into();
        let test_expression = shy.compile().unwrap();

        let variables_used_rro = test_expression.variables_used().clone();
        let variables_used_ro = variables_used_rro.as_ref().read().unwrap();
        let used = variables_used_ro.as_ref().unwrap();
        let expected_definitions : Vec<String> = vec!["x".into(), "y".into()];
        let expected_dependencies : Vec<String> = vec!["well.depth".into()];
        asserting("Definitions match").that(&do_vecs_match(&expected_definitions, &used.definitions)).is_equal_to(true);
        asserting("Dependencies match").that(&do_vecs_match(&expected_dependencies, &used.dependencies)).is_equal_to(true);
    }

    #[test]
    /// Test the untangle function, which sorts expressions so that no expression that expects a given variable to be defined
    /// is evaluated before the expression that defines it. 
    fn untangle() {
        // These expressions cannot be evaluated in the order given. They must be "untangled". 
        let expression_source = vec!(
            "z = x + y",
            "d = 2 * c - k",
            "a = z / b; c = 10",
            "x = 3; y = 9",
            "k = 5",
            "b = 2",
            "42"
        );
        // Expected values
        let a = 6;
        let b = 2; 
        let c = 10;
        let d = 15;
        let k = 5;
        let x = 3;
        let y = 9;
        let z = 12;

        let mut context = ExecutionContext::default();
        let expressions : Vec<Expression> = expression_source.iter().map(|s| Expression::new(*s)).collect();
        let (sorted, unsorted) = Expression::untangle(expressions);
        asserting!("All expressions should be sortable").that(&unsorted).has_length(0);
        for expr in sorted.iter().map(|expr_rc| { let x : &Expression = expr_rc.borrow(); x }) {
            let _ = expr.exec(&mut context);
        }
        asserting("value of a").that(&variable_equals("a", a, &context)).is_equal_to(true);
        asserting("value of b").that(&variable_equals("b", b, &context)).is_equal_to(true);
        asserting("value of c").that(&variable_equals("c", c, &context)).is_equal_to(true);
        asserting("value of d").that(&variable_equals("d", d, &context)).is_equal_to(true);
        asserting("value of k").that(&variable_equals("k", k, &context)).is_equal_to(true);
        asserting("value of x").that(&variable_equals("x", x, &context)).is_equal_to(true);
        asserting("value of y").that(&variable_equals("y", y, &context)).is_equal_to(true);
        asserting("value of z").that(&variable_equals("z", z, &context)).is_equal_to(true);
    }

    fn do_vecs_match<T : PartialEq>(a : &Vec<T>, b : &Vec<T>) -> bool {
        let matching = a.iter().zip(b.iter()).filter(|&(a, b)| a == b).count();
        matching == a.len() && matching == b.len()
    }

    fn variable_equals(variable : &str, expected_value : i64, ctx : &ExecutionContext) -> bool {
        match ctx.load(&variable.to_string()) {
            Some(ShyValue::Scalar(ShyScalar::Integer(actual_value_int))) => expected_value == actual_value_int,
            Some(ShyValue::Scalar(ShyScalar::Rational(actual_value_float))) => expected_value as f64 == actual_value_float,
            _ => false
        }
    }

}
