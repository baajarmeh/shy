
use crate::parser::expression::Expression;
use crate::parser::expression::Expressive;

custom_derive! {
#[derive(Copy, Clone, Debug, PartialEq, Eq, EnumDisplay, EnumFromStr, IterVariants(RuleTypeVariants), IterVariantNames(RuleTypeVariantNames))]
  pub enum RuleType {
      /// Indicates that the rule defines one or more properties. 
      /// It may return a boolean or a value of any supported type. 
      Property,

      /// Indicates that the Rule returns a boolean and is a pass/fail rule. 
      Predicate
  }
}

/// A Rule for use in a rule engine. 
/// 
/// A Rule is an expression that conforms to a special format. 
/// The values of most properties of the rule can be extracted from the Expression.
/// For example, if the expression has the phrase `rule.description = "Is the well in the US?"`
/// then the description property can be set. These property chains can be used
/// to specify Rule properties:
/// 
///   - rule.name
///   - rule.id
///   - rule.description
///   - rule.type
///   - rule.category
///   - rule.sequence
pub struct Rule<'a> {
    /// Name of rule.
    /// 
    /// If not supplied in the expression via an assignment to property chain `rule.name`, the name will be "Rule" + id. 
    pub name : String,

    /// Unique integer id for a rule. 
    /// 
    /// If the expression sets `rule.id`, that value overrides the value passed into the Rule constructor.
    pub id : u32,

    /// User friendly description of the rule's intent. 
    /// 
    /// If the expression does not assign a string to property chain `rule.description`, 
    /// the description will be `Option::None`.
    /// 
    /// If the rule is a predicate, this should be phrased as a question such that if 
    /// the answer to the question is "Yes", the rule passes.
    /// 
    /// ## Examples: 
    ///    - Is the mud depth less than 5000 ft?   GOOD! It is specific and a true answer implies passing. 
    ///    - Is the mud depth too great?            BAD! It is not specific and a true answer implies failing. 
    pub description : Option<String>,

    /// Type of rule, which defaults to Predicate. 
    pub rule_type : RuleType,

    /// Optional rule category. 
    pub category : Option<String>,

    /// Optional Execution sequence specified by rule creator. 
    /// 
    ///   1. Rules with a sequence will be evaluated in that order. 
    ///   2. All other rules will be evaluated after the sequenced rules, in random order. 
    ///   3. Unmet dependencies will be generated by recursively evaluating the rules
    ///      that define those dependencies. 
    /// 
    /// If the expression does not assign a number to property chain `rule.sequence`, 
    /// the sequence will be `Option::None`.
    pub sequence : Option<u32>,

    /// Required expression to be evaluated for this rule.
    ///
    /// The expression should return a boolean for Predicate type rules, but may return any value for Property type rules. 
    expression : Expression<'a>,

    /// Names of all properties and property chains that this rule defines. 
    /// 
    /// This list is derived by analyzing the Expression, to find all variables and property chains
    /// that are defined within the expression before their first use.
    ///
    /// Property chains that begin with "rule." are excluded, as they define meta data common to many rules. 
    definitions : Vec<String>,

    /// Names of all properties and property chains that this rule references but does not also define.
    /// 
    /// This list is derived by analyzing the Expression, to find all variables and property chains
    /// that are used within the expression either without being defined or before they are defined.
    ///
    /// Property chains that begin with "rule." are excluded, as they define meta data common to many rules. 
    dependencies : Vec<String>
}

impl<'a> Expressive<'a> for Rule<'a> {
    fn express(&self) -> &Expression<'a> { &self.expression }
    fn express_mut(&mut self) -> &mut Expression<'a> { &mut self.expression }
}


